// api/prices.js (โค้ด Serverless Function บน Vercel)

// 1. กำหนด Item ID และ Locations ที่คุณต้องการ (T6-T8)
const itemIds = [
    "T6_BAG", 
    "T7_BAG", 
    "T8_BAG", 
    // ... ใส่ Item ID อาวุธ ชุดเกราะ T6-T8 ทั้งหมด
];

const locations = [
    "Black Market", 
    "Bridgewatch", 
    "Martlock", 
    "Fort Sterling", 
    "Thetford", 
    "Lymhurst", 
    "Caerleon"
];

const QUALITY = 1; // Normal Quality

const FEE_RATE = 0.065; // 6.5%

export default async function handler(req, res) {
    try {
        // 2. สร้าง URL API
        const apiUrl = `https://west.albion-online-data.com/api/v2/stats/prices/${itemIds.join(',')}` +
                       `?locations=${locations.join(',')}` +
                       `&qualities=${QUALITY}`;

        // 3. ดึงข้อมูลจาก Albion API
        const response = await fetch(apiUrl);
        const data = await response.json();

        // 4. ประมวลผลและคำนวณกำไร
        // โค้ดส่วนนี้จะทำงานซับซ้อนกว่าใน Sheets เล็กน้อย แต่หลักการเดียวกัน
        
        // ก. หาข้อมูล Black Market (BM) Sell Price Max (O)
        const bmData = data.filter(d => d.city === "Black Market");
        const bmMap = new Map();
        bmData.forEach(item => {
            // เราใช้ buy_price_max (I) ของ BM เพื่อคำนวณราคาขาย (O)
            const sellPriceGross = item.buy_price_max / (1 - FEE_RATE);
            bmMap.set(item.item_id, sellPriceGross);
        });

        // ข. คำนวณกำไรสำหรับเมืองหลัก
        const results = data
            .filter(d => d.city !== "Black Market" && d.sell_price_min > 0)
            .map(cityItem => {
                const itemId = cityItem.item_id;
                const buyPrice = cityItem.sell_price_min; // ราคาซื้อ (M)
                const sOrderPriceGross = bmMap.get(itemId) || 0; // ราคาตั้งขายที่ BM (T)

                // ถ้าไม่มีราคา BM หรือราคาซื้อแพงเกินไป ก็ข้าม
                if (sOrderPriceGross === 0 || sOrderPriceGross <= buyPrice) {
                    return null;
                }

                const revenueAfterFee = sOrderPriceGross * (1 - FEE_RATE); // ราคาขายสุทธิ (Q)
                const finalProfit = revenueAfterFee - buyPrice; // กำไรสุทธิ (P)

                return {
                    itemId: itemId,
                    city: cityItem.city,
                    buyPrice: buyPrice,
                    sellPriceGross: sOrderPriceGross.toFixed(0),
                    finalProfit: finalProfit.toFixed(0),
                    margin: ((finalProfit / buyPrice) * 100).toFixed(2) + '%'
                };
            })
            .filter(Boolean) // ลบแถวที่เป็น null ทิ้ง
            .sort((a, b) => b.finalProfit - a.finalProfit); // เรียงกำไรมากไปน้อย

        // 5. ส่งผลลัพธ์กลับไปให้เบราว์เซอร์
        res.status(200).json(results);
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
}